{"name":"SB-Adapter01 V1.1","type":"com.fibaro.energyMeter","apiVersion":"1.2","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_519"},"sections":{"items":[{"components":[{"name":"message","style":{"weight":"1.2"},"text":"Headline","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"statemessage","style":{"weight":"1.2"},"text":"Statusmeldungen","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"time","style":{"weight":"1.2"},"text":"Time","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"consum","style":{"weight":"1.2"},"text":"VerbrauchErzeugung","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"gridfeed","style":{"weight":"1.2"},"text":"EinspeisungBezug","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"pac","style":{"weight":"1.2"},"text":"EntladungLadung ","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"rsoc","style":{"weight":"1.2"},"text":"RSOC","type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_519"}}},"uiCallbacks":[],"quickAppVariables":[{"name":"ip","value":"192.168.178.37"},{"name":"wait","value":"no"},{"name":"interval","value":"60"},{"name":"globalValues","value":"no"},{"name":"Timestamp","value":"2020-08-04 17:44:12"},{"name":"OnlineState","value":"OnGrid"},{"name":"Production_kW","value":1.107},{"name":"Consumption_kW","value":0.32},{"name":"GridFeedIn_kW","value":0.783},{"name":"Pac_kW","value":-0.005},{"name":"SOC_%","value":"100"}],"typeTemplateInitialized":true},"files":[{"name":"main","isMain":true,"isOpen":true,"content":"-- sbAdpater1 V1.1\n-- Adapter für die sonnenBatterie Ec0 8.0 und Eco10\n-- QuickApp für das System Fibaro HC3\n-- Der Adapter fragt ausgewählte Daten der Batterie zyklisch ab und stellt diese in einer Anzeige, als lokale Variablen und als Globale Variablen zur Verfügung\n-- Copyright (C) 2020  Thomas Burchert, 10Consult\n\n-- GNU General Public License\n--- Dieses Programm ist freie Software. Sie können es unter den Bedingungen der GNU General Public License, wie von der Free Software Foundation veröffentlicht, weitergeben und/oder modifizieren, entweder gemäß Version 3 der Lizenz oder (nach Ihrer Wahl) gemäß jeder späteren Version. Die Veröffentlichung dieses Programms erfolgt in der Hoffnung, daß es Ihnen von Nutzen sein wird, aber OHNE IRGENDEINE GARANTIE, sogar ohne die implizite Garantie der MARKTREIFE oder der VERWENDBARKEIT FÜR EINEN BESTIMMTEN ZWECK. Details finden Sie in der GNU General Public License. Sie sollten ein Exemplar der GNU General Public License zusammen mit diesem Programm erhalten haben. Falls nicht, finden Sie ein Exemplar der GNU General Public License zu diesem Programm hier:  <https://www.gnu.org/licenses/>\n\n--- This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, see <https://www.gnu.org/licenses/>.\n\n-- Parameter, Settings\n--- ip: IP-Adresse der Batterie\n--- interval: Zeitintervall für die Abfrage der Livedaten\n--- wait: yes/no, der Adapter geht bei \"yes\" in den Wartezustand (Leerlauf)\n--- globaleValues: yes/no, der Adapter speichert die Livedaten zusätzlich im Bereich der globalen Variablen ab.\n\n-- Hinweis: die sonnenBatterie und der Fibaro-HC3-Hub müssen im selben Netzwerk angemeldet sein!\n\n-- API-Queries\n--- http://<ip-sonnenBatterie>:8080/api/v1/status\n\n-- Lokale Werte: werden in Variablenübersicht der QuickApp gespeichert\n-- Globale Werte: werden in der zentralen Variablenübersicht von Fibaro gespeichert; dafür die Globalen Variablen dort manuell hinzufügen und die lokale Variable \"globaleValue\" auf \"yes\" stellen!\n\n-- ==============LUA-SCRIPT-CODE=====================================\n\n-- QuickApp: onInit()\n-- bei Start der QuickApp, Initialiiserung\nfunction QuickApp:onInit()\n\tself:debug(\"sbAdapter1 gestartet (init sbA1)\")\n    self:updateView(\"statemessage\", \"text\", \"Message: >>> sbAdapter1 gestartet (init sbA1)\")\t\n\n   -- check values\n    if (self:getVariable(\"ip\")) then\n    else self:setVariable('ip','change-ip')\n    end\n    if (self:getVariable(\"wait\")) then\n    else self:setVariable('wait','yes')\n    end\n    if (self:getVariable(\"interval\")) then\n    else self:setVariable('interval','60000')\n    end\n    if (self:getVariable(\"globalValues\")) then\n    else self:setVariable('globalValues','no')\n    end\n    self:readData(\"sbA1 - Start reading Livedata\") -- start readDate()\nend\n\n-- QuickApp: readData()\n-- Routine für Datenabfrage, Datenaufbereitung, Datenanzeige\n-- local address = \"http://<ip-adresse>:8080/api/v1/status\"\nfunction QuickApp:readData(message)\n    self:debug(message)\n    self.looptime = tonumber(self:getVariable(\"interval\")) -- string value to number\n    self.ip = self:getVariable(\"ip\")\n    self.wait = self:getVariable(\"wait\")\n    self.go = \"yes\" \n    self.setGlobalValues = self:getVariable(\"globalValues\")\n    \n    -- Check the Start-Values \"change-ip\", \"interval\", \"wait\" \n    if  (self.ip == \"change-ip\") then\n        self:trace(\"sbA1 - please change the ip-address!\") -- Value \"change-ip\"= not correct IP-Address\n        self:updateView(\"statemessage\", \"text\", \"Message: >>> sbA1 - please change the ip-address!\")\t\n        self.go = \"no\"\n    end\n    if  (self.looptime < 60) then\n    self:trace(\"sbA1, Error - interval to small! Value= \",self.looptime) -- value \"interval\" zu niedrig!\n    self:updateView(\"statemessage\", \"text\", \"Message: >>> sbA1, Error - interval to small!\")\t\n    self.looptime = 60\n    self:setVariable(\"interval\",'60') -- value correction\n    self.go = \"no\"\n    end\n    if  (self.wait == \"yes\") then\n        self:debug(\"sbA1 is waiting!\") -- Value \"wait\"= yes\n        self:updateView(\"statemessage\", \"text\", \"Message: >>> sbA1 is waiting!\")\n        self.go = \"no\"\n    end\n    -- Hauptroutine, main routine\n    if (self.go == \"yes\") then\n        self:debug(\"sbA1 - start data request\")\n        \n        -- looptime berechnen\n        self.looptime = self.looptime*1000 -- Zyklus für rd. 120 sec\n        \n        -- start data request sbAdapter\n        self.http = net.HTTPClient({timeout=1000})\n        local address = \"http://\"..self:getVariable(\"ip\")..\":8080/api/v1/status\"\n\t    self.http:request(address, {\n\t\t    options={headers = {Accept = \"application/json\"}, method = 'GET'},\n\t\t        success = function(response)\n                self:debug(\"sbA1 - data response was successful!\")\n\n\t\t\t    local sbdata = json.decode(response.data)\n\t\t\n                -- prepare live data for view\t\t\t\n                local strTimestamp = sbdata.Timestamp -- string value  \n                self:setVariable(\"Timestamp\",strTimestamp)  \n            \n                local strSystemStatus = sbdata.SystemStatus -- string value\n                self:setVariable(\"OnlineState\",strSystemStatus)\n\t\t\t\n                local iProduction = sbdata.Production_W -- integer value\n                iProduction = iProduction/1000\n                self:setVariable(\"Production_kW\",iProduction)\n                strProduction = string.format(\"%.3f\", iProduction) -- now string value\n\n                local iConsumption = sbdata.Consumption_W\n\t\t\t    iConsumption = iConsumption/1000\n                self:setVariable(\"Consumption_kW\",iConsumption)\t\n\t\t\t    strConsumption = string.format(\"%.3f\", iConsumption)\t\n\n\t\t\t    local str = sbdata.GridFeedIn_W\n                str = str/1000\n                self:setVariable(\"GridFeedIn_kW\",str)\n\t\t\t    strGridFeedIn = string.format(\"%.3f\", str)\n                \n\t\n\t\t\t    local iPac_total = sbdata.Pac_total_W\n\t\t\t    iPac_total = iPac_total/1000\n                self:setVariable(\"Pac_kW\",iPac_total)\n\t\t\t    strPac_total = string.format(\"%.3f\", iPac_total)\n\t\t\t\n\t\t\t    local iRSOC = sbdata.RSOC\n\t\t\t    iRSOC = string.format(\"%.0f\", iRSOC)\n                self:setVariable(\"SOC_%\",iRSOC)\n                strRSOC = string.format(\"%.0f\", iRSOC)\n\n                -- Write Global Values to Fibaro memory\n                -- Schreiben Globaler Variablen in zentrale Variablenverwaltung\n                -- leider kann Fibaro nur String-Werte gespeichern\n                if  (self.setGlobalValues == \"yes\") then\n                    fibaro.setGlobalVariable(\"sbTimestamp\", strTimestamp)\n                    fibaro.setGlobalVariable(\"sbSystemStatus\", strSystemStatus)\n                    fibaro.setGlobalVariable(\"sbProduction\", strProduction)\n                    fibaro.setGlobalVariable(\"sbConsumption\", strConsumption)\n                    fibaro.setGlobalVariable(\"sbGridFeedIn\", strGridFeedIn)\n                    fibaro.setGlobalVariable(\"sbPac_total\", strPac_total)\n                    fibaro.setGlobalVariable(\"sbRSOC\", strRSOC)\n                    self:debug(\"sbA1 - save Global Values to Fibaro! Ready\")\n                    self:updateView(\"statemessage\", \"text\", \"Message: >>> sbAdapter1 okay & ready\")\n                end\n\n                -- Prepare data for inside QA-View\n                -- Daten für interne QA-Anzeige speichern\n  \t\t\t    local vMessage = \"------------- LIVEDATEN-ANZEIGE für Eco 8.0 / Eco 10 -------------\"\n\t\t\t    self:updateView(\"message\", \"text\", vMessage)              \n\n\t\t\t    local vTimestamp = \"Zeit: \" ..strTimestamp..\" - Status: \"..strSystemStatus..\"!\"\n\t\t\t    self:updateView(\"time\", \"text\", vTimestamp)\n            \n                local vConsumption = \"Erzeugung: \"..strProduction..\" kW / Verbrauch: \"..strConsumption.. \" kW\"\n\t\t\t    self:updateView(\"consum\", \"text\", vConsumption)\n\n\t\t\t    local vGridFeedIn = \"Einspeisung / Bezug(-): \" ..strGridFeedIn..\" kW\"\n\t\t\t    self:updateView(\"gridfeed\", \"text\", vGridFeedIn)\n\n\t\t\t    local vPac_total = \"Entladung / Ladung(-): \" ..strPac_total..\" kW\"\n\t\t\t    self:updateView(\"pac\", \"text\", vPac_total)\n\n\t\t\t    local vRSOC = \"SOC: \" ..strRSOC..\" %\"\n\t\t\t    self:updateView(\"rsoc\", \"text\", vRSOC)\t\n        end,\n\t\terror = function(error)\n\t\t\tself:error('error: ' .. json.encode(error))\n\t\tend\n\t    })\n    end\n    -- Pooling für zyklischen Abruf der Livedaten\n    -- self:debug(\"Timeout sec: \",self.looptime)\n    fibaro.setTimeout(self.looptime, function()\n    self:readData(\"sbA1 - activate polling!\")\n    end)\nend"}]}